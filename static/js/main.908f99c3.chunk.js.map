{"version":3,"sources":["constants/index.ts","components/SnakeGame/SnakeGame.tsx","hooks/useInterval.ts","components/App/App.tsx","reportWebVitals.ts","index.tsx","components/SnakeGame/SnakeGame.module.scss"],"names":["INITIAL_SNAKE_POS","x","y","DIRECTION_START","FOOD_START","CANVAS_SCALE","DIRECTIONS","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","SnakeGame","cellSize","fieldLength","canvasRef","useRef","useState","direction","setDirection","snake","setSnake","food","setFood","speed","setSpeed","score","setScore","started","setStarted","level","setLevel","isOver","setIsOver","getCanvasContext","current","getContext","getCanvasSize","getBoundingClientRect","width","renderSquare","color","ctx","fillStyle","fillRect","createRandomFood","Math","floor","random","checkCollision","part","_snake","segment","gameLoop","newSnake","newSnakeHead","unshift","newFood","prevScore","prevLevel","prevSpeed","checkFoodCollision","pop","useEffect","height","context","setTransform","canvasSize","clearRect","strokeStyle","lineWidth","moveTo","lineTo","stroke","renderGrid","forEach","callback","delay","savedCallback","id","setInterval","clearInterval","useInterval","className","s","root","canvasWrapper","canvas","tabIndex","ref","onKeyDown","e","_direction","key","startBtn","onClick","focus","gameOverMsg","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","module","exports"],"mappings":"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","file":"static/js/main.908f99c3.chunk.js","sourcesContent":["// types and interfaces\n\nexport interface ICell {\n  x: number,\n  y: number,\n}\n\nexport interface ISnakeProps {\n  cellSize: number,\n  fieldLength: number,\n}\n\ntype directionsType = {\n  [key: string]: ICell,\n}\n\n// initial states\n\nexport const INITIAL_SNAKE_SIZE: number = 5;\nexport const INITIAL_SNAKE_POS: Array<ICell> = [{ x: 8, y: 7 }, { x: 8, y: 8 }];\nexport const DIRECTION_START: ICell = { x: 0, y: -1 };\nexport const FOOD_START: ICell = { x: 8, y: 3 };\nexport const CANVAS_SCALE: number = 20;\nexport const INITIAL_SPEED: number = 270;\nexport const DIRECTIONS: directionsType = {\n  ArrowUp: { x: 0, y: -1 },\n  ArrowDown: { x: 0, y: 1 },\n  ArrowLeft: { x: -1, y: 0 },\n  ArrowRight: { x: 1, y: 0 },\n};\n\n// colors\n\nexport const COLOR_RED = 'red';\nexport const COLOR_GREEN = 'green';\nexport const COLOR_GRAY = '#DDDDDD';\nexport const COLOR_WHITE = '#FFFFFF';\n","import React, { useState, useEffect, useRef } from 'react';\nimport { useInterval } from 'hooks/useInterval';\nimport {\n  ICell,\n  COLOR_RED,\n  FOOD_START,\n  DIRECTIONS,\n  COLOR_GRAY,\n  ISnakeProps,\n  COLOR_GREEN,\n  COLOR_WHITE,\n  CANVAS_SCALE,\n  INITIAL_SPEED,\n  DIRECTION_START,\n  INITIAL_SNAKE_POS,\n} from 'constants/index';\n\nimport s from './SnakeGame.module.scss';\n\nconst SnakeGame = ({ cellSize, fieldLength }: ISnakeProps) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [direction, setDirection] = useState<ICell>(DIRECTION_START);\n  const [snake, setSnake] = useState<Array<ICell>>(INITIAL_SNAKE_POS);\n  const [food, setFood] = useState<ICell>(FOOD_START);\n  const [speed, setSpeed] = useState<number | null>(null);\n  const [score, setScore] = useState<number>(0);\n  const [started, setStarted] = useState<boolean>(false);\n  const [level, setLevel] = useState<number>(1);\n  const [isOver, setIsOver] = useState<boolean>(false);\n\n  // Canvas helpers and basic functionality\n  const getCanvasContext = (): CanvasRenderingContext2D | null => {\n    if (canvasRef && canvasRef.current) {\n      return canvasRef.current.getContext('2d');\n    }\n\n    return null;\n  };\n\n  const setCanvasSize = (): void => {\n    if (canvasRef && canvasRef.current) {\n      canvasRef.current.width = cellSize * fieldLength;\n      canvasRef.current.height = cellSize * fieldLength;\n    }\n  };\n\n  const getCanvasSize = (): number => {\n    if (canvasRef && canvasRef.current) {\n      const { width: canvasSize } = canvasRef.current.getBoundingClientRect();\n\n      return canvasSize;\n    }\n\n    return 0;\n  };\n\n  const focusCanvas = (): void => {\n    if (canvasRef && canvasRef.current) {\n      canvasRef.current.focus();\n    }\n  };\n\n  const renderSquare = (x: number, y: number, color: string): void => {\n    const ctx = getCanvasContext();\n\n    if (ctx) {\n      ctx.fillStyle = color;\n      ctx.fillRect(x, y, 1, 1);\n    }\n  };\n\n  const renderGrid = (): void => {\n    const context = getCanvasContext();\n    if (context) {\n      context.setTransform(CANVAS_SCALE, 0, 0, CANVAS_SCALE, 0, 0);\n      const canvasSize = getCanvasSize();\n      context.clearRect(0, 0, canvasSize, canvasSize);\n      context.fillStyle = COLOR_GRAY;\n      context.strokeStyle = COLOR_WHITE;\n      context.fillRect(0, 0, canvasSize, canvasSize);\n      context.lineWidth = 1 / CANVAS_SCALE;\n\n      for (let x = 1; x < canvasSize; x += 1) {\n        context.moveTo(x, 0);\n        context.lineTo(x, canvasSize);\n      }\n\n      for (let y = 0; y < canvasSize; y += 1) {\n        context.moveTo(0, y);\n        context.lineTo(canvasSize, y);\n      }\n\n      context.stroke();\n    }\n  };\n\n  // Snake game general logic\n  const moveSnake = (_direction: string) => {\n    if (\n      direction.x + DIRECTIONS[_direction].x &&\n      direction.y + DIRECTIONS[_direction].y\n    ) {\n      setDirection(DIRECTIONS[_direction]);\n    }\n  };\n\n  const createRandomFood = (): ICell => ({\n    x: Math.floor((Math.random() * getCanvasSize()) / CANVAS_SCALE),\n    y: Math.floor((Math.random() * getCanvasSize()) / CANVAS_SCALE),\n  });\n\n  const checkCollision = (part: ICell, _snake: ICell[] = snake): boolean => {\n    // Check snake collisions\n    for (const segment of _snake) {\n      if (part.x === segment.x && part.y === segment.y) {\n        return true;\n      }\n    }\n\n    // Check walls collisions\n    if (\n      part.x * CANVAS_SCALE >= getCanvasSize() ||\n      part.x < 0 ||\n      part.y * CANVAS_SCALE >= getCanvasSize() ||\n      part.y < 0\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  const checkFoodCollision = (newSnake: ICell[]): boolean => {\n    if (newSnake[0].x === food.x && newSnake[0].y === food.y) {\n      let newFood = createRandomFood();\n      while (checkCollision(newFood, newSnake)) {\n        newFood = createRandomFood();\n      }\n      setFood(newFood);\n      setScore(prevScore => prevScore + 1);\n      if (speed && speed > 10) {\n        setLevel(prevLevel => prevLevel + 1);\n        setSpeed(prevSpeed => prevSpeed && prevSpeed - 10);\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  const startGame = (): void => {\n    focusCanvas();\n    setStarted(true);\n    setIsOver(false);\n    setSnake(INITIAL_SNAKE_POS);\n    setFood(FOOD_START);\n    setDirection(DIRECTION_START);\n    setSpeed(INITIAL_SPEED);\n  };\n\n  const endGame = (): void => {\n    setSpeed(null);\n    setIsOver(true);\n  };\n\n  const gameLoop = (): void => {\n    const newSnake = [...snake];\n    const newSnakeHead: ICell = {\n      x: newSnake[0].x + direction.x,\n      y: newSnake[0].y + direction.y,\n    };\n    newSnake.unshift(newSnakeHead);\n    if (checkCollision(newSnakeHead)) endGame();\n    if (!checkFoodCollision(newSnake)) newSnake.pop();\n    setSnake(newSnake);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent): void => {\n    const { key } = e;\n    // Check if key is one of the arrows\n    if (\n      key === 'ArrowUp' ||\n      key === 'ArrowDown' ||\n      key === 'ArrowRight' ||\n      key === 'ArrowLeft'\n    ) {\n      moveSnake(key);\n    }\n  };\n\n  useEffect(() => {\n    setCanvasSize();\n  }, []);\n\n  useEffect(() => {\n    const context = getCanvasContext();\n    if (context) {\n      renderGrid();\n      snake.forEach(({ x, y }) => renderSquare(x, y, COLOR_GREEN));\n      renderSquare(food.x, food.y, COLOR_RED);\n    }\n  }, [snake, food]);\n\n  useInterval(() => gameLoop(), speed);\n\n  return (\n    <div className={s.root}>\n      <div className={s.canvasWrapper}>\n        <canvas\n          className={s.canvas}\n          tabIndex={0}\n          ref={canvasRef}\n          onKeyDown={handleKeyDown}\n        />\n        {(!started || isOver) && (\n          <button className={s.startBtn} onClick={startGame}>\n            {isOver ? 'Try again' : 'Start Game'}\n          </button>\n        )}\n        {isOver && (\n          <p className={s.gameOverMsg}>You have failed this snake</p>\n        )}\n      </div>\n      <p>Your score: {score}</p>\n      <p>Current level: {level}</p>\n    </div>\n  );\n}\n\nexport default SnakeGame;\n","import { useEffect, useRef } from 'react';\n\nexport function useInterval(callback: any, delay: number | null) {\n  const savedCallback = useRef<() => void | null>();\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    function tick() {\n      if (typeof savedCallback?.current !== 'undefined') {\n        savedCallback.current();\n      }\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}\n","import React from 'react';\n\nimport SnakeGame from 'components/SnakeGame';\n\nconst App = () => <SnakeGame cellSize={20} fieldLength={30} />;\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from 'components/App';\n\nimport reportWebVitals from './reportWebVitals';\n\nimport './styles/index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"SnakeGame_root__3yvKs\",\"canvasWrapper\":\"SnakeGame_canvasWrapper__2V9rr\",\"canvas\":\"SnakeGame_canvas__2s_Sz\",\"startBtn\":\"SnakeGame_startBtn__97pxl\",\"gameOverMsg\":\"SnakeGame_gameOverMsg__34sm6\"};"],"sourceRoot":""}